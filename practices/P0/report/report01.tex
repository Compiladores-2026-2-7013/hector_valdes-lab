\documentclass[12pt, a4paper]{article}

% --- Paquetes ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{amsmath, amssymb}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{multicol}

\geometry{margin=2.5cm}

% --- Configuración de listings ---
\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  language=bash,
  showstringspaces=false
}

% --- Commands ---- %

\newcommand{\solution}{\textit{Solution}}


% --- Datos ---
\title{Práctica 0 --- Etapas de Compilación \\[0.5em]
\large Compiladores --- Semestre 2026-2}
\author{Hector Valdes}
\date{}

\begin{document}
\maketitle

% ============================================================
\section{Introducción}
% ============================================================

En esta práctica se exploran las etapas del proceso de compilación de un
programa escrito en lenguaje C, desde el preprocesamiento hasta el enlazado.
Se utiliza cada herramienta de forma individual para observar las
transformaciones que sufre el código fuente en cada fase.

% ============================================================
\section{Desarrollo}
% ============================================================

% ------------------------------------------------------------
\subsection{Preprocesamiento (\texttt{cpp})}
% ------------------------------------------------------------

Se ejecutó el siguiente comando para generar el archivo preprocesado:

\begin{lstlisting}
cpp programa.c programa.i
\end{lstlisting}

\begin{enumerate}[label=\alph*)]
  \item ¿Qué ocurre cuando se invoca el comando \texttt{cpp} con esos argumentos? \par
    cpp es un procesador de macros, particularmente para lenguajes de programacion de la familia de C. Este programa, nos ayuda a interpretar directivos de procesamiento, por ejemplo \textbf{\#include, \#define, \#ifdef, etc.}.
    Por lo tanto, cuando ejecutamos el comando \textit{cpp}. Este, lee el documento de entrada (\textit{progama.c}) y los
    documentos que hayan sido incluidos por el directivo \textbf{\#include} y los escribe con la informacion extra generada por los directivos en el programa de salida, \textit{programa.i}.

  \item ¿Qué similitudes encuentra entre los archivos \texttt{programa.c} y \texttt{programa.i}? \par
  En el archivo, \texttt{programa.i}, al final, se puede ver el siguiente codigo:
    \begin{figure}
    \begin{lstlisting}
    int main ( void ) {
      printf ("Hola Mundo !\\n");
      float mi_area = (r) (3.1416 * r * r) (3) ;
      printf ("Resultado : %f\n", mi_area);
      return 0;
    }
    \end{lstlisting}
    \caption{\textit{Parte final del archivo programa.i}}
    \end{figure}
    \begin{figure}
    \begin{lstlisting}
    int main ( void ) {
      printf ("Hola Mundo !\n"); //Funcion para imprimir hola mundo
      float mi_area = area (3) ; //soy un comentario... hasta donde llegare ?
      printf ("Resultado : %f\n", mi_area);
      return 0;
    }
    \end{lstlisting}
    \caption{\textit{Etracto de programa.c}}
    \end{figure}
    En la figura 1, podemos ver que las sentencias han sido limpiadas de comentarios, y tambien el macro \textbf{area} ha sido remplazado con su definicion. Pero ambos son programas que saludan al mundo e imprimen el area de un circulo con radio 3.
  \item ¿Qué pasa con las macros y los comentarios del código fuente original? \par
  Los macros, son remplazados de manera textual en todas las llamadas de este. Por ejemplo, recordemos
  la definicion de area:
  \begin{figure}
  \begin{lstlisting}
  # ifdef PI
  # define area (r) (PI * r * r)
  # else
  # define area (r) (3.1416 * r * r)
  # endif
  \end{lstlisting}
  \caption{Definicion de Area en programa.c}
  \end{figure}
  Asi, notemos que como no tenemos un directivo que defina PI, se toma la deficion la segunda definicion, la cual podemos ver que es la usada en la Figura 1.
    Y los comentarios son eliminados, dado que no son necesarios para la etapa de compilacion, solo para el programador.
  \item Compare el contenido de \texttt{programa.i} con el de \texttt{stdio.h} e indique de forma general las similitudes entre ambos archivos. \par
    Debido a que hay muchas funciones de stdio.h en programa.i sin directivos de compilacion condicional, ni otro directivo en general. Pienso que \textit{cpp} hace un preprocesado en stdio,h y la salida de este preprocesado solo es remplazado con el directivo de \textbf{\#include}. Por lo tanto las similitudes, son las definiciones de ciertas funciones.
\end{enumerate}

% ------------------------------------------------------------
\subsection{Compilación (\texttt{gcc -S})}
% ------------------------------------------------------------

Se ejecutó la siguiente instrucción:

\begin{lstlisting}
gcc -Wall -S programa.i
\end{lstlisting}

\begin{enumerate}[label=\alph*)]
\item ¿Para qué sirve la opción \texttt{-Wall}? \par
  Para que el sistema de procesamiento \textit{gcc}, muestre todas las advertencias(Warnings) al construir el codigo objeto.
\item ¿Qué le indica a \texttt{gcc} la opción \texttt{-S}? \par
  Que detenga su ejecucion despues de haber compilado, antes de ensamblar.
\item ¿Qué contiene el archivo de salida y cuál es su extensión? \par
  Su extension es .s y contiene instrucciones en lenguaje ensamblador generadas con ayuda del archivo \textit{programa.i}.
\end{enumerate}

% ------------------------------------------------------------
\subsection{Ensamblado (\texttt{as})}
% ------------------------------------------------------------

Se ejecutó la siguiente instrucción:

\begin{lstlisting}
as programa.s -o programa.o
\end{lstlisting}

\begin{enumerate}[label=\alph*)]
\item Antes de revisarlo, indique cuál es su hipótesis sobre lo que debe contener el archivo con extensión \texttt{.o}.
  \par
  Yo pienso que nos dara el codigo maquina en bytes de nuestro programa escrito en ensamblador.
\item Diga de forma general qué contiene el archivo \texttt{programa.o} y por qué se visualiza de esa manera. \par
Contiene lo que yo creo son bytes y strings que parecen ser etiquetas de lenguaje ensamblador. Estas etiquetas son llamadas directivos e indican instrucciones al momento de el ensamblado.
\item ¿Qué programa se invoca con \texttt{as}?
El ensamblador de GNU. Est programa permite ensamblar codigo ensamblador de diferentes arquitecturas en una pasada.
\end{enumerate}

% ------------------------------------------------------------
\subsection{Enlazado (\texttt{ld})}
% ------------------------------------------------------------

Se buscó la ruta de los siguientes archivos en el equipo de trabajo:

\begin{itemize}
  \item \texttt{ld-linux-x86-64.so.2}
  \item \texttt{Scrt1.o} (o bien, \texttt{crt1.o})
  \item \texttt{crti.o}
  \item \texttt{crtbeginS.o}
  \item \texttt{crtendS.o}
  \item \texttt{crtn.o}
\end{itemize}

Se ejecutó el siguiente comando:

\begin{lstlisting}
ld -o ejecutable -dynamic-linker /lib/ld-linux-x86-64.so.2 \
   /usr/lib/Scrt1.o /usr/lib/crti.o programa.o \
   -lc /usr/lib/crtn.o
\end{lstlisting}

\begin{enumerate}[label=\alph*)]
  \item En caso de que el comando \texttt{ld} mande errores, investigue cómo
        enlazar un programa utilizando \texttt{ld} y proponga una posible
        solución para llevar a cabo este proceso con éxito.

  \item Describa el resultado obtenido al ejecutar el comando anterior.

    Generamos el codigo en lenguaje maquina, finalmente. El argumento -o indica el nombre que le daremos al archivo de salida en este caso \textbf{ejecutable}. El siguiente argumento, -dynamic-linker es una flag que indica que enlazador usaremos, en este caso \textit{/lib/ld-linux-x86-64.so.2}.
    Los siguientes argumentos son archivos objeto. Scrt1.o crti.o crtn.o son encargados de crear rutinas para la apertura y el cierre de el ejecutable. Despues, viene el archivo objeto creado por nosotros. En esta parte, tambien vemos la bandera -lc la cual nos ayuda a enlazar \textbf{libc}, la libreria estandar de c.
\end{enumerate}

% ------------------------------------------------------------
\subsection{Ejecución}
% ------------------------------------------------------------

\begin{lstlisting}
./ejecutable
\end{lstlisting}

% ------------------------------------------------------------
\subsection{Modificación de la macro \texttt{\#define PI}}
% ------------------------------------------------------------

Se quitó el comentario de la macro \texttt{\#define PI} en el código fuente
original y se realizó lo siguiente:

\begin{enumerate}[label=\alph*)]
  \item Se generó nuevamente el archivo \texttt{.i} con un nuevo nombre.

  \item ¿Cambia en algo la ejecución final?
\end{enumerate}

% ------------------------------------------------------------
\subsection{Segundo programa con directivas del preprocesador}
% ------------------------------------------------------------

Se escribió un segundo programa en lenguaje C que incluye 4 directivas del
preprocesador distintas entre sí y diferentes de las utilizadas en el primer
programa.\footnote{Puede consultarse la lista de directivas en la documentación
en línea:
\url{https://gcc.gnu.org/onlinedocs/cpp/Index-of-Directives.html}.
También se puede revisar la entrada para el preprocesador con
\texttt{man cpp}.}

\begin{enumerate}[label=\alph*)]
  \item Explique la utilidad general de cada directiva y su función particular
        en el programa.
\end{enumerate}

% ============================================================
\section{Resultados y Conclusiones}
% ============================================================



\end{document}
